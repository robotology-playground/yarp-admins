/*
 *  A simple example to control Cuddie motors
 *  Copy Policy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 *  Authors: Ali Paikan <ali.paikan@gmail.com>
 *
 */


#include <ngraph.hpp>
#include <yarp/os/Network.h>
#include <yarp/os/LogStream.h>
#include <yarp/os/ContactStyle.h>
#include <yarp/os/Bottle.h>
#include <yarp/os/Port.h>

#include <sstream>
#include <iostream>

using namespace std;
using namespace yarp::os;
using namespace NGraph;


bool yarp_name_list(vector<string>& ports) {
    ports.clear();
    ContactStyle style;
    style.quiet = true;
    style.timeout = 3.0;
    Bottle cmd, reply;
    cmd.addString("list");
    if(!NetworkBase::writeToNameServer(cmd, reply, style)) {
        yError() << "Cannot write to yarp name server";
        return false;
    }
    if(!reply.size()) {
        yError() << "Empty reply from yarp name server";
        return false;
    }

    istringstream f(reply.get(0).asString());
    string s;
    while (getline(f, s)) {
        size_t pos = s.find_first_of("/");
        if(pos != std::string::npos) {
            string str = s.substr(pos);
            str = str.substr(0, str.find(" "));
            if(str != NetworkBase::getNameServerName())
                ports.push_back(str);
        }
    }
    return true;
}

bool getPortDetails(const string& portName, PortDetails& info) {

    yInfo()<<"Cheking "<<portName<<"...";
    info.name = portName;
    Port ping;
    ping.open("/yarpviz");
    ping.setAdminMode(true);
    if(!NetworkBase::connect(ping.getName(), portName)) {
        yWarning()<<"Cannot connect to"<<portName;
        ping.close();
        return false;
    }

    // Getting output connections list
    Bottle cmd, reply;
    cmd.addString("list"); cmd.addString("out");
    if(!ping.write(cmd, reply)) {
        yError()<<"Cannot write (list out) to"<<portName;
        return false;
    }
    for(int i=0; i<reply.size(); i++) {
        ConnectionInfo cnn;
        cnn.name = reply.get(i).asString();
        Bottle reply2;
        cmd.clear();
        cmd.addString("list"); cmd.addString("out"); cmd.addString(cnn.name);
        if(!ping.write(cmd, reply2))
            yWarning()<<"Cannot write (list out"<<cnn.name<<") to"<<portName;
        else
            cnn.carrier =  reply2.find("carrier").asString();
        info.outputs.push_back(cnn);
    }

    // Getting input connections list
    cmd.clear(); reply.clear();
    cmd.addString("list"); cmd.addString("in");
    if(!ping.write(cmd, reply)) {
        yError()<<"Cannot write (list in) to"<<portName;
        return false;
    }
    for(int i=0; i<reply.size(); i++) {
        ConnectionInfo cnn;
        cnn.name = reply.get(i).asString();
        if(cnn.name != ping.getName())
            info.inputs.push_back(cnn);
    }

    // Getting owner info
    cmd.clear(); reply.clear();
    cmd.addString("prop"); cmd.addString("get"); cmd.addString(portName);
    if(!ping.write(cmd, reply)) {
        yError()<<"Cannot write (prop get"<<portName<<") to"<<portName;
        return false;
    }

    Property* process = reply.find("process").asDict();
    if(!process)
        yWarning()<<"Cannot find 'process' property of port "<<portName;
    else {
        info.owner.name = process->find("name").asString();
        info.owner.arguments = process->find("arguments").asString();
        info.owner.pid = process->find("pid").asInt();
        info.owner.priority = process->find("priority").asInt();
        info.owner.policy = process->find("policy").asInt();
    }

    Property* platform = reply.find("platform").asDict();
    if(!platform)
        yWarning()<<"Cannot find 'platform' property of port "<<portName;
    else {
        info.owner.os = platform->find("os").asString();
        info.owner.hostname = platform->find("hostname").asString();
    }

    ping.close();
    return true;
}

vector<GenericNode>::iterator findPortNodeByName(vector<GenericNode>& nodes, const string name) {
    GenericNode n;
    n.info.name = name;
    return std::find(nodes.begin(), nodes.end(), n);
}

int main(int argc, char* argv[])
{
    // initializing yarp network
    yarp::os::Network yarp;

    /*
    tGraph<color> A;
    A.insert_edge(blue, red);
    A.insert_edge(yellow, blue);
    A.insert_edge(blue, black);
    A.print();*/

    yInfo()<<"Getting the ports list...";
    vector<string> ports;
    yarp_name_list(ports);

    yInfo()<<"Getting the ports details...";
    vector<GenericNode> portNodes;
    for(int i=0; i<ports.size(); i++) {
        GenericNode node;
        if(getPortDetails(ports[i], node.info))
            portNodes.push_back(node);
    }

    yInfo()<<"Generating the graph...";
    tGraph<GenericNode> graph;
    // Createing nodes for the processes and linking them to their ports
    vector<GenericNode>::iterator itr;
    vector<GenericNode> processNodes;
    for(itr=portNodes.begin(); itr!=portNodes.end(); itr++) {
        PortDetails& info = (*itr).info;
        GenericNode node(GenericNode::PROCESS, info);
        if(std::find(processNodes.begin(), processNodes.end(), node) == processNodes.end() )
            processNodes.push_back(node);
        // adding edges
        vector<GenericNode>::iterator pitr = std::find(processNodes.begin(), processNodes.end(), node);
        if(info.inputs.size())
            graph.insert_edge(*itr, *pitr);
        if(info.outputs.size())
            graph.insert_edge(*pitr, *itr);
    }

    // create link between ports (connections)
    for(itr=portNodes.begin(); itr!=portNodes.end(); itr++) {
        PortDetails& info = (*itr).info;
        std::vector<ConnectionInfo>::iterator citr = info.outputs.begin();
        for(;citr!=info.outputs.end(); citr++) {
            ConnectionInfo cnn = *citr;
            vector<GenericNode>::iterator nitr = findPortNodeByName(portNodes, cnn.name);
            if(nitr==portNodes.end())
                yWarning()<<"Cannot find any port with name"<<cnn.name;
            else
                graph.insert_edge(*itr, *nitr);
        }
    }

    graph.print();


    /*
    vector<GenericNode>::iterator nitr = findPortNodeByName(portNodes, "/Left/grabber");
    tGraph<GenericNode>::vertex_set s;
    s.insert(*nitr);
    tGraph<GenericNode> a = graph.subgraph(s);
    //yInfo()<<"\n";
    //a.print();
    */

    /*
    for(itr=processNodes.begin(); itr!=processNodes.end(); itr++)
        yInfo()<<(*itr).info.owner.name<<(*itr).info.owner.pid;
    */

    /*
   //b graph.find()
    vector<GenericNode>::iterator itr;
    for(itr=portNodes.begin(); itr!=portNodes.end(); itr++) {
        PortDetails& info = (*itr).info;
        yInfo()<<"\n"<<info.toString();
        yInfo()<<" ";
    }
    */
    return 0;
}

